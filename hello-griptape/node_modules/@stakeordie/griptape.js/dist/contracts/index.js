"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var __spreadArray = (this && this.__spreadArray) || function (to, from) {
    for (var i = 0, il = from.length, j = to.length; i < il; i++, j++)
        to[j] = from[i];
    return to;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.buildMessage = exports.executeMultiMessage = exports.instantiateContract = exports.refContract = exports.extendContract = exports.createContract = exports.ContractTxResponseHandler = void 0;
var secretjs_1 = require("secretjs");
var bootstrap_1 = require("../bootstrap");
var bootstrap_2 = require("../bootstrap");
var errors_1 = require("./errors");
var utils_1 = require("./utils");
var decoder = new TextDecoder('utf-8');
var QUERY_TYPE = 'query';
var MESSAGE_TYPE = 'message';
var contractRegistry = [];
var ContractTxResponseHandler = (function () {
    function ContractTxResponseHandler(response) {
        this.response = response;
    }
    ContractTxResponseHandler.prototype.parse = function () {
        return JSON.parse(decoder.decode(this.response.data));
    };
    ContractTxResponseHandler.prototype.getRaw = function () {
        return this.response;
    };
    ContractTxResponseHandler.prototype.isEmpty = function () {
        return typeof this.response === 'undefined';
    };
    ContractTxResponseHandler.of = function (response) {
        return new ContractTxResponseHandler(response);
    };
    return ContractTxResponseHandler;
}());
exports.ContractTxResponseHandler = ContractTxResponseHandler;
function getContext(contractAddress) {
    return __awaiter(this, void 0, void 0, function () {
        var address, key, height, padding, entropy, permit, rawPermit;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    address = bootstrap_1.getAddress();
                    key = bootstrap_2.viewingKeyManager.get(contractAddress);
                    return [4, bootstrap_1.getHeight()];
                case 1:
                    height = _a.sent();
                    padding = utils_1.getEntropyString(32);
                    entropy = window.btoa(utils_1.getEntropyString(32));
                    rawPermit = localStorage.getItem("query_permit_" + (address + contractAddress));
                    if (rawPermit) {
                        permit = JSON.parse(rawPermit);
                    }
                    return [2, { address: address, key: key, height: height, padding: padding, entropy: entropy, permit: permit }];
            }
        });
    });
}
function handleResponse(txHash) {
    return __awaiter(this, void 0, void 0, function () {
        var result, tx, error_1;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    result = false;
                    _a.label = 1;
                case 1:
                    if (!true) return [3, 7];
                    _a.label = 2;
                case 2:
                    _a.trys.push([2, 4, , 5]);
                    return [4, bootstrap_1.getSigningClient().restClient.txById(txHash)];
                case 3:
                    tx = _a.sent();
                    if (!tx.raw_log.startsWith('[')) {
                        result = false;
                    }
                    else {
                        result = true;
                    }
                    return [3, 7];
                case 4:
                    error_1 = _a.sent();
                    return [3, 5];
                case 5: return [4, utils_1.sleep(6000)];
                case 6:
                    _a.sent();
                    return [3, 1];
                case 7: return [2, { found: result, response: tx }];
            }
        });
    });
}
function createContract(contract) {
    var codeHash = contract.codeHash;
    var handler = {
        get: function (contract, prop) {
            var _this = this;
            if (typeof contract[prop] !== 'function') {
                return Reflect.get(contract, prop);
            }
            return new Proxy(contract[prop], {
                get: function (func, prop) {
                    if (prop === 'target') {
                        return func;
                    }
                    return Reflect.get(func, prop);
                },
                apply: function (func, thisArg, argumentsList) { return __awaiter(_this, void 0, void 0, function () {
                    var contractAddress, ctx, args, result, _, _a, handleMsg, memo, rawTransferAmount, fees, calculatedFee, transferAmount, response, config, result_1, txResponse, e_1, errorHandler;
                    return __generator(this, function (_b) {
                        switch (_b.label) {
                            case 0:
                                contractAddress = contract.at;
                                return [4, getContext(contractAddress)];
                            case 1:
                                ctx = _b.sent();
                                args = __spreadArray([ctx], argumentsList);
                                result = Reflect.apply(func, thisArg, args);
                                if (!(func.type === QUERY_TYPE)) return [3, 2];
                                _ = undefined;
                                return [2, bootstrap_1.queryContract(contractAddress, result, _, codeHash)];
                            case 2:
                                if (!(func.type === MESSAGE_TYPE)) return [3, 9];
                                _a = result, handleMsg = _a.handleMsg, memo = _a.memo, rawTransferAmount = _a.transferAmount, fees = _a.fees;
                                calculatedFee = utils_1.getFeeForExecute(fees);
                                transferAmount = rawTransferAmount
                                    ? [rawTransferAmount]
                                    : [];
                                _b.label = 3;
                            case 3:
                                _b.trys.push([3, 8, , 9]);
                                return [4, bootstrap_1.executeContract(contractAddress, handleMsg, memo, transferAmount, calculatedFee, codeHash)];
                            case 4:
                                response = _b.sent();
                                config = bootstrap_1.getConfig();
                                if (!config)
                                    throw new Error('No config available');
                                if (!(config.broadcastMode == secretjs_1.BroadcastMode.Sync)) return [3, 6];
                                return [4, handleResponse(response.transactionHash)];
                            case 5:
                                result_1 = _b.sent();
                                if (result_1.found && result_1.response) {
                                    txResponse = result_1.response;
                                    return [2, ContractTxResponseHandler.of(txResponse)];
                                }
                                else {
                                    throw new Error("Could not found TX: " + response.transactionHash);
                                }
                                return [3, 7];
                            case 6: return [2, ContractTxResponseHandler.of(response)];
                            case 7: return [3, 9];
                            case 8:
                                e_1 = _b.sent();
                                errorHandler = errors_1.getErrorHandler(contract.id, e_1);
                                if (errorHandler) {
                                    errorHandler.handler();
                                }
                                else {
                                    throw e_1;
                                }
                                return [3, 9];
                            case 9: return [2, Reflect.apply(func, thisArg, argumentsList)];
                        }
                    });
                }); },
            });
        },
    };
    var id = contract.id, at = contract.at, _a = contract.definition, q = _a.queries, m = _a.messages;
    var queries = q || {};
    var messages = m || {};
    Object.keys(queries).forEach(function (it) { return (queries[it].type = QUERY_TYPE); });
    Object.keys(messages).forEach(function (it) { return (messages[it].type = MESSAGE_TYPE); });
    var target = __assign(__assign({ id: id, at: at }, queries), messages);
    var result = new Proxy(target, handler);
    var idx = contractRegistry.findIndex(function (it) { return it.id === contract.id; });
    if (idx === -1) {
        contractRegistry.push(result);
    }
    return result;
}
exports.createContract = createContract;
function extendContract(base, extended) {
    var _a = base.messages, baseMessages = _a === void 0 ? {} : _a, _b = base.queries, baseQueries = _b === void 0 ? {} : _b;
    var _c = extended.messages, defMessages = _c === void 0 ? {} : _c, _d = extended.queries, defQueries = _d === void 0 ? {} : _d;
    var baseMessagesKeys = Object.keys(baseMessages);
    var defMessagesKeys = Object.keys(defMessages);
    var messageKeys = utils_1.calculateCommonKeys(baseMessagesKeys, defMessagesKeys);
    var baseQueriesKeys = Object.keys(baseQueries);
    var defQueriesKeys = Object.keys(defQueries);
    var queriesKey = utils_1.calculateCommonKeys(baseQueriesKeys, defQueriesKeys);
    var result = {
        messages: __assign(__assign({}, base.messages), extended.messages),
        queries: __assign(__assign({}, base.queries), extended.queries),
    };
    messageKeys.forEach(function (key) {
        result.messages[key] = defMessages[key];
    });
    queriesKey.forEach(function (key) {
        result.queries[key] = defQueries[key];
    });
    return result;
}
exports.extendContract = extendContract;
function refContract(idOrAddress) {
    var contract = contractRegistry.find(function (it) { return it.id === idOrAddress || it.at === idOrAddress; });
    if (!contract)
        throw new Error("No contract found with id or address " + idOrAddress);
    return contract;
}
exports.refContract = refContract;
function instantiateContract(req) {
    return __awaiter(this, void 0, void 0, function () {
        var id, definition, codeId, label, initMsg, at, spec;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    id = req.id, definition = req.definition, codeId = req.codeId, label = req.label, initMsg = req.initMsg;
                    return [4, bootstrap_1.instantiate(codeId, initMsg, label)];
                case 1:
                    at = (_a.sent()).contractAddress;
                    spec = {
                        id: id,
                        at: at,
                        definition: definition,
                    };
                    return [2, createContract(spec)];
            }
        });
    });
}
exports.instantiateContract = instantiateContract;
function executeMultiMessage(infos, memo) {
    return __awaiter(this, void 0, void 0, function () {
        var messages, fees, _i, infos_1, info, contractAddress, ctx, message, transferAmount, entry, response;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    messages = [];
                    fees = 0;
                    _i = 0, infos_1 = infos;
                    _a.label = 1;
                case 1:
                    if (!(_i < infos_1.length)) return [3, 4];
                    info = infos_1[_i];
                    contractAddress = info.contract.at;
                    return [4, getContext(contractAddress)];
                case 2:
                    ctx = _a.sent();
                    message = info.getMessage.apply(info, __spreadArray([ctx], info.args));
                    transferAmount = message.transferAmount
                        ? [message.transferAmount]
                        : [];
                    entry = {
                        contractAddress: contractAddress,
                        handleMsg: message.handleMsg,
                        transferAmount: transferAmount,
                    };
                    messages.push(entry);
                    fees += message.fees ? message.fees : 0;
                    _a.label = 3;
                case 3:
                    _i++;
                    return [3, 1];
                case 4: return [4, bootstrap_1.getSigningClient().multiExecute(messages, memo, utils_1.getFeeForExecute(fees))];
                case 5:
                    response = _a.sent();
                    return [2, ContractTxResponseHandler.of(response)];
            }
        });
    });
}
exports.executeMultiMessage = executeMultiMessage;
function buildMessage(contract, message) {
    var args = [];
    for (var _i = 2; _i < arguments.length; _i++) {
        args[_i - 2] = arguments[_i];
    }
    var getMessage = message.target;
    return { getMessage: getMessage, contract: contract, args: args };
}
exports.buildMessage = buildMessage;
//# sourceMappingURL=index.js.map